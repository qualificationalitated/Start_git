# [9017](https://www.acmicpc.net/problem/9017)

## 크로스 컨트리

### 문제

---

크로스 컨트리 달리기는 주자들이 자연적인 야외의 지형에 만들어진 코스를 달리는 운동 경기이다. 경주 코스는 일반적으로 4에서 12 킬로미터이며, 숲이나 넓은 땅을 통과하는 풀과 흙으로 된 지면과 언덕과 평평한 지형을 포함한다. 이 경기는 주자들의 개인성적을 매기고, 이를 가지고 팀의 점수를 계산한다.

한 팀은 여섯 명의 선수로 구성되며, 팀 점수는 상위 네 명의 주자의 점수를 합하여 계산한다. 점수는 자격을 갖춘 팀의 주자들에게만 주어지며, 결승점을 통과한 순서대로 점수를 받는다. 이 점수를 더하여 가장 낮은 점수를 얻는 팀이 우승을 하게 된다. 여섯 명의 주자가 참가하지 못한 팀은 점수 계산에서 제외된다. 동점의 경우에는 다섯 번째 주자가 가장 빨리 들어온 팀이 우승하게 된다.

예를 들어, 다음의 표를 살펴보자.

|등수|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|팀|A|B|C|C|A|C|B|D|A|A|C|A|C|C|A|
|점수|1|n/a|2|3|4|5|n/a|n/a|6|7|8|9|10|11|12|

팀 B 와 D 는 선수의 수가 여섯이 아니므로, 점수를 받을 수 없다. 팀 A 의 점수는 18 (1+4+6+7)이고, 팀 C 의 점수는 18 (2+3+5+8)이다. 이 경우 두 팀의 점수가 같으므로 다섯 번째로 결승점을 통과한 선수를 고려한다, A 팀의 다섯 번째 선수의 점수가 C 팀의 다섯 번째 선수의 점수보다 적으므로 A 팀이 우승팀이 된다.

모든 선수들의 등수가 주어질 때, 우승팀을 구하는 프로그램을 작성하라. 각 팀의 참가 선수가 여섯보다 작으면 그 팀은 점수 계산에서 제외됨을 주의하라. 여섯 명 보다 많은 선수가 참가하는 팀은 없고, 적어도 한 팀은 참가 선수가 여섯이며, 모든 선수는 끝까지 완주를 한다고 가정한다.

### 입력

---

입력 데이터는 표준입력을 사용한다. 입력은 T 개의 테스트 케이스로 주어진다. 입력 파일의 첫 번째 줄에 테스트 케이스의 수를 나타내는 정수 T 가 주어진다. 두 번째 줄부터는 두 줄에 하나의 테스트 케이스에 해당하는 데이터가 주어진다. 각 테스트 케이스의 첫 번째 줄에는 하나의 정수 N (6 ≤ N ≤ 1,000)이 주어진다. 두 번째 줄에는 팀 번호를 나타내는 N 개의 정수 $t_1$, $t_2$, …, $t_N$ 이 공백을 사이에 두고 주어진다. 각 팀은 1 과 M(1 ≤ M ≤ 200)사이의 정수로 표현된다.

### 출력

---

출력은 표준출력을 사용한다. 하나의 테스트 케이스에 대한 우승팀의 번호를 한 줄에 출력한다.

## 코드

```c++
#include<iostream>
#include<vector>
#define RUNNER 1001
#define TEAM 201
using namespace std;
typedef struct{
    int team, score;
}runner;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    int t,n;
    cin>>t;
    while(t--){
        int score=1;
        int max = 200*200,ans = 0,fifth = RUNNER;
        runner list[RUNNER];
        int rankCount[TEAM] = {0,};
        vector<int> teamScoreOver6[TEAM];
        cin>>n;
        for(int i=0;i<n;i++){
            cin>>list[i].team;
            rankCount[list[i].team]++;
        }
        for(int i=0;i<n;i++){
            runner currRunner = list[i];
            if(rankCount[currRunner.team]>=6){
                currRunner.score = score++;
                teamScoreOver6[currRunner.team].push_back(currRunner.score);
            }
        }
        for (int i = 1; i < TEAM; i++)
        {
            int sum = 0;
            if(teamScoreOver6[i].size()){
                for (int j = 0; j < 4; j++) sum += teamScoreOver6[i][j];
                if(sum < max || (sum == max && fifth > teamScoreOver6[i][4])){
                    max = sum;
                    ans = i;
                    fifth = teamScoreOver6[i][4];
                }
            }
        }
        
        cout<<ans<<"\n";
    }
    return 0;
}
```

## 풀이

단순 구현문제.

처음엔 들어오는 순서대로 점수를 메기면 되겠지 생각했다가, 뒤늦게 점수와 등수는 다르다는 것을 파악해 구현방식을 바꾼 문제.  
처음에는 `unordered_map<int, vector<int>>` 를 사용해 팀과, 팀에 해당하는 점수를 입력과 동시에 저장하고자 했으나, 그냥 단순 배열과 벡터를 활용하는 형태로 바꿨다, 사실 안 바꿨어도 될 듯 했다.  

참여자들의 팀을 모두 입력받으며 팀원의 수를 체크한 후, 팀원의 수가 6명이 넘는 팀 만을 고려해 결승점을 통과한 선수들의 점수를 메기며, 각 팀별 점수 목록을 벡터 형태로 저장한다.  
이후, 벡터 길이가 6 이상인(사실 팀원 수 6이상을 판단해뒀으니, 벡터 길이로 판단하는것은 비효율적일듯 하다) 선수들의 점수 총합을 계산해 비교하며 정답을 판단하고, 출력한다.
