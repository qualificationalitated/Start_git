# 15486

[문제 링크](https://www.acmicpc.net/problem/15486)

> __퇴사 2__
> n+1일 뒤 퇴사하는 직원에게, 남은 n일간 진행 가능한 업무가 주어진다.  
> 각 업무별 소요일수와, 업무 완료시 획득 가능한 보너스 정보가 주어질때, 최대한 많은 보너스를 얻는것이 목표다  
> 퇴사 직전까지 직원이 획득 가능한 보너스의 MAX를 구해보자  

## 코드

```c++

#include<cstdio>
#include<algorithm>
using namespace std;
double list[1500001]={0,};
int main(){
    int n,t,p;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d %d",&t,&p);
        list[i+t] = max( list[i+t], list[i]+p);
        list[i+1] = max( list[i], list[i+1]);
    }
    printf("%.0lf",list[n+1]);
    return 0;
}
```

## 풀이

DP를 활용해 문제를 해결했다.

처음에는 모든 시간과 비용을 입력받고 하향식으로 알고리즘을 풀고자 했는데..  
자꾸 오류가 나서, 풀이를 바꿨다.  

특정한 업무를 처리했을때 얻을 수 있는 이익의 최대치를 list에 정리한다.  
list[i] = i번째 일 직전까지 얻을 수 있는 최대 이득을 의미함.  
1~n일까지 부여된 업무를 입력받으며, 해당 업무를 끝낼시 얻을 수 있는 이익을 list배열의 i+t(업무에 걸리는 시간) 번째에 기록한다.  
이때, 기존의 값과 비교해 더 큰값을 기록한다.
이후, i+1 값을 판단하며 다음날의 최대값을 갱신해준다.

나중에 하향식 풀이 + 다른 상향식 풀이(배열 안쓰고) 한번 풀어보자.
