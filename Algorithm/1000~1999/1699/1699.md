# [1699](https://www.acmicpc.net/problem/1699)

> __제곱수의 합__
>
> 자연수 N이 주어질때, 주어진 자연수를 제곱수로 나타내는데 필요한 제곱수의 최소 갯수를 구해보자.

## 코드

```c++
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
int dp[100002]={0,};
int main(){
    int n;
    cin>>n;
    dp[0]=0; dp[1]=1;
    for(int i=0;i<=n;i++)  dp[i]=i; // 전부 초기화 해주고
    for(int i=1;i<=n;i++){ // 1부터 n까지 돌면서 dp 테이블을 채울겁니다
        // 1부터 sqrt(i)까지 돌면서, 갱신하고자 하는 값을 갱신해줍니다
        // x 값을 만들고자 할 때, 기존의 값과, dp[x-(sqrt(x)보다 작은 정수의 제곱값)] + 1을 비교
        // 이때 왜 1을 더하냐? - sqrt(x)보다 작은 정수의 제곱값을 사용해서 1 더해주는거
        for(int j=1;j*j<=i;j++){
            dp[i] = min(dp[i] , dp[i-j*j] + 1);
        }
    }
    cout<<dp[n];
    return 0;
}
```

## 풀이

dp를 활용해 문제를 해결했다.  

처음엔 그리디하게 큰 제곱수부터 뺴주면 될 줄 알았는데, 41 - 25 + 16과 같은 경우에 오답이 출력되어 풀이를 변경했다.

dp테이블을 활용해 각 수를 만드는데 필요한 최소 제곱수를 기록한다.  
초기에는 모든 수를 1로 만든다는 생각으로 dp 테이블을 초기화 해준다.  
이후, 1부터 입력받은 n 값까지 돌면서 dp 테이블을 채워준다.  
특정한 값 i의 최소 횟수를 알기 위해, j로 1부터 sqrt(i)보다 작은 수까지 돌며, j의 제곱값을 활용했을때의 최소 구성횟수를 계산한다.  
해서, 1부터 sqrt(i)까지 탐색하며 i를 만들기 위한 최소 제곱수를 얻고, i는 또 n까지 돌면서 목표하는 수를 구성하기 위한 최소 제곱수의 수를 구한다.  

왜 오늘은 유난히 머리가 안돌까요, [참고](https://chanhuiseok.github.io/posts/baek-10/)를 참고해 문제를 해결했습니다.
