# [1715](https://www.acmicpc.net/problem/1715)

> __카드 정렬하기__
>
> 정렬된 두 묶음의 숫자 카드가 있다고 하자.  
> 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다.  
> 매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다.  
> N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

## 코드

```c++
#include <iostream>
#include <queue> 
#include <algorithm>
using namespace std; 
typedef long long ll; 
int main() {
    int n,m;
    ll input,answer = 0;
    priority_queue<ll, vector<ll>, greater<ll>> pq;
    cin>>n>>m; 
    for (int i = 0; i < n; i++) {
        cin >> input; 
        pq.push(input); 
    }
    while (m--) {
        ll sum=0;
        for (int i = 0; i < 2; i++){
            sum+=pq.top();
            pq.pop();
        }
        for (int i = 0; i < 2; i++)
            pq.push(sum); 
    }
    while (!pq.empty()) {
        answer += pq.top(); 
        pq.pop(); 
    }
    cout << answer; 
    return 0;
}
```

## 풀이

우선순위 큐 + 그리디를 활용한 문제.

이전에 해결한 문제인 [카드 합체 놀이](https://www.acmicpc.net/problem/15903)와 유사한 문제.  
그래서 그런지 왜이렇게 높게 난이도가 설정된건지.. 모르겟다.  

직관적으로 봤을때, 연산의 수를 작게 하기 위해선 가장 적은 카드가 있는 두 묶음의 카드를 비교하는 식으로 진행하는 것이 정답이다.  
따라서, 오름차순 정렬 우선순위 큐를 활용해 입력을 정렬한 후, 큐 내 원소가 1개 남을때까지 반복해 최소 원소 2개 pop 이후 합을 push 하는 연산을 진행한다.  
이 과정에서 카드간 비교 횟수를 누적하고, 모든 비교가 끝난 후 이를 출력한다.  

### 트리 증명

위 문제의 카드 비교 순서를 트리로 나타낸다면 아래와 같다.

```bash
# 최적의 경우
70
├── 40
└── 30
    ├── 10
    └── 20

# 최악의 경우
70
├── 10
└── 60
    ├── 40
    └── 20
```

위 트리의 리프노드는 처음 주어진 카드 묶음에 대응하는 노드들이며, 부모 노드의 값은 자식 노드 값들의 합을 의미한다.  
또한, 전체 비교 횟수는 리프노드를 제외한 모든 노드의 값의 합이며, 이는 각 리프노드의 값과 깊이를 곱한 값 (리프노드의 값 x 깊이)의 합을 의미한다.  
여기서, 최적의 묶는 방식은 항상 가장 작은 2개의 노드가 가장 깊은 곳의 리프노드에 배치되어야 함을 의미하며, 만일 그렇지 않다면 더욱 효과적인 방식이 존재함을 의미하며, 이는 곧 수학적 귀납법을 통해 증명이 가능하다.  
증명은 아래와 같다.  

가정 : 묶음의 개수가 N개일 때 최적의 묶는 방식은 가장 작은 두 개의 묶음을 합치는 과정을 반복하는 것이다.

1. N = 2인 경우 귀납 가정은 참이다.  
   - N = 2인 경우 묶는 방식은 유일하기 때문이다.
2. N = K인 경우 귀납 가정이 참이라고 가정하자.
3. N = K + 1인 경우
   - 위 정리에 의해, 최적화된 묶는 방식에서 가장 먼저 묶는 두 개의 묶음은 크기가 가장 작은 둘이다.
   - 두 개를 묶고 나면 K개의 묶음이 남으므로 귀납 가정에 의해 가장 작은 두 개의 묶음을 합치는 과정을 반복하는 것이 최적이다.
   - 따라서, N = K+1 일때도 위 귀납과정은 성립한다.  
