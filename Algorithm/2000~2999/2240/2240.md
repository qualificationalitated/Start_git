# [2240](https://www.acmicpc.net/problem/2240)

> __자두나무__
>
> 어떤 방법을 써도 열매에 손이 닿지 않을만큼 높은 자두나무가 주인공 집 마당에 2그루 존재한다.  
> 주인공은 앞으로 T초동안, 1초에 1개씩 자두가 하늘에서 땅바닥으로 떨어진다는 사실을 입수했다.  
> 주인공은 자두가 바닥에 충돌해 형체를 알아볼 수 없게 되기 전에, 공중에 있는 자두를 매우 특별한 방법으로 손상없이 안전하게 받을 수 있다 할때, 떨어지는 자두를 얻어보자.  
> 자두가 떨어지는 나무 아래 주인공이 서 있다면 자두를 수확할 수 있으며, 주인공은 w번 만큼만 각 나무를 이동하고자 할때, 획득 가능한 최대한의 자두의 수를 구하는 문제.

## 코드

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int dp[1002][31]={0,};
int main(){
    int t,w,fall,ans=-1;
    cin>>t>>w;
    for(int i=1;i<=t;i++){
        cin>>fall;
        dp[i][0] = dp[i-1][0] + (fall == 1);
        for(int j=1;j<=w;j++)
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + (fall==1+(j%2));
    }
    for(int j=0;j<=w;j++)
        ans=max(ans,dp[t][j]);
    cout<<ans;
    return 0;
}
```

## 풀이

DP를 활용해 문제를 해결했다.

t초동안 자두가 떨어지는 나무의 번호를 입력받으며, dp\[x][y](x초에 y번 이동했을때 얻을 수 있는 최대 수확량) 테이블을 채워나간다.  
한번도 이동하지 않았을경우(dp의 0열)는 1번 나무 아래 위치하므로, 자두가 떨어진 나무가 1인지 판단해 수를 카운트 한다.  
이후, 1부터 w번까지 이동할 수 있는 경우를 탐색하며, 이번 차례에 이동하기 or 이미 이동한 상태에서 가만히 있기 중 더 큰값을 선택한 후, 이동한 차례의 위치에 자두가 떨어졌는지 판단하며 갯수를 센다.  
모든 탐색이 종료되면, 획득 가능한 가장 많은 수의 자두 갯수를 출력한다.
