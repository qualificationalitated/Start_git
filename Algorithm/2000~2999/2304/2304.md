# [2304](https://www.acmicpc.net/problem/2304)

## 창고 다각형

### 문제

---

N 개의 막대 기둥이 일렬로 세워져 있다. 기둥들의 폭은 모두 1 m이며 높이는 다를 수 있다. 이 기둥들을 이용하여 양철로 된 창고를 제작하려고 한다. 창고에는 모든 기둥이 들어간다. 이 창고의 지붕을 다음과 같이 만든다.

1. 지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.
2. 지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.
3. 지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.
4. 지붕의 가장자리는 땅에 닿아야 한다.
5. 비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.

그림 1은 창고를 옆에서 본 모습을 그린 것이다. 이 그림에서 굵은 선으로 표시된 부분이 지붕에 해당되고, 지붕과 땅으로 둘러싸인 다각형이 창고를 옆에서 본 모습이다. 이 다각형을 창고 다각형이라고 하자.

|높이   ||||||||||||||||||
|:-:|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|12 ||||||||||||||||||
|11 |||||||||_|||||||||
|10 ||||||||\||█|\|||||||||
|9  ||||||||\||█||_|_|_|_|_|_||
|8  ||||||||\||█|||||||█|\||
|7  |||||_|_|_||█|||||||█|\||
|6  ||||\||█||||█|||||█||█|\||
|5  || |_||█||||█|||||█||█|\||
|4  ||\||█||█||||█|||█||█||█|\||
|3  ||\||█||█|█|||█|||█||█||█|\||
|2  ||\||█||█|█|||█|||█||█||█|\||
|1  ||\||█||█|█|||█|||█||█||█|\||

창고 주인은 창고 다각형의 면적이 가장 작은 창고를 만들기를 원한다. 그림 1에서 창고 다각형의 면적은 98 ㎡이고, 이 경우가 가장 작은 창고 다각형이다.

기둥들의 위치와 높이가 주어질 때, 가장 작은 창고 다각형의 면적을 구하는 프로그램을 작성하시오.

### 입력

---

첫 줄에는 기둥의 개수를 나타내는 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 그 다음 N 개의 줄에는 각 줄에 각 기둥의 왼쪽 면의 위치를 나타내는 정수 L과 높이를 나타내는 정수 H가 한 개의 빈 칸을 사이에 두고 주어진다. L과 H는 둘 다 1 이상 1,000 이하이다.

### 출력

---

첫 줄에 창고 다각형의 면적을 나타내는 정수를 출력한다.

## 코드

```c++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct pillar{
    int loc, hei;
};
bool cmpLoc(const pillar a, const pillar b){
    return a.loc<b.loc;
}
bool cmpAsc(const pillar a, const pillar b){
    return a.hei<b.hei;
}
bool cmpDesc(const pillar a, const pillar b){
    return a.hei>b.hei;
}
int main(){
    int n, ans = 0;
    pillar hst = {-1,-1};
    vector<pillar> list;
    cin>>n;
    list.resize(n);
    for(int i=0;i<n;i++)
        cin>>list[i].loc>>list[i].hei;
    sort(list.begin(),list.end(), cmpLoc);
    
    for(int i=0;i<n;i++)
        if(list[i].hei > hst.hei){
            hst.hei = list[i].hei;
            hst.loc = i; // index
        }
    sort(list.begin(),list.begin()+hst.loc, cmpAsc); // 앞은 오름차순 정렬
    sort(list.begin()+hst.loc+1,list.end(), cmpDesc); // 뒤는 내림차순 정렬
    int idx = hst.loc-1, mIdx = hst.loc;
    while(idx > -1){
        if(list[idx].loc < list[mIdx].loc){
            ans += (list[mIdx].loc - list[idx].loc) * list[idx].hei;
            mIdx = idx;
        }
        idx--;
    }
    idx = hst.loc+1, mIdx = hst.loc;
    while(idx < n){
        if(list[idx].loc > list[mIdx].loc){
            ans += (list[idx].loc - list[mIdx].loc) * list[idx].hei;
            mIdx = idx;
        }
        idx++;
    }
    cout<<ans + hst.hei<<"\n";
    return 0;
}
```

## 풀이

구현 문제

모든 기둥을 입력받고, 기둥의 위치를 기준으로 정렬을 진행한다.
다음, 모든 기둥을 순회하며 가장 높은 기둥의 높이와 인덱스를 확인한 후, 각 기둥의 높이에 대해 가장 높은 기둥을 기준으로 왼편은 오름차순, 오른편은 내림차순 정렬을 진행한다.  
다음 왼편 기둥은 역순으로 순회하며 순서가 역전되지 않는 경우, 지붕 내 오목한 부분이 발생하지 않음을 보장하며 최소 면적을 보장하는 넓이를 구한다.  
마찬가지로 오른편은 올바른 순서대로 순회하며 순서가 역전되지 않는 경우, 지붕 내 오목한 부분과 최소 면적이 보장되는 넓이를 구한다.  
마지막으로, 중앙 기둥의 넓이를 더한 후 답을 출력하고, 종료한다.  

백준 설명에 따르면, __스택 문제다..!__  
이걸 어떻게..? 하는 생각이 들긴 하는데..  
아마 기둥 순서대로 정렬 후, 가장 큰 높이를 확인하고, 0번 순서부터 스택에 넣으면서 규칙에 맞게 너비를 정리해나가는 식이 아닐까 싶다.  
이렇게 하면 더 효율적이다, 불필요한 정렬을 안해도 되니 말이다.  
