# 2579

[문제 링크](https://www.acmicpc.net/problem/2579)

> __계단 오르기__
> 각 칸마다 점수가 적힌 계단을 오른다고 한다.  
> 한번에 한계단, 혹은 두계단을 오를수 있으며, 연속된 세 계단은 밟으면 안된다.  
> 또한, 마지막 도착 계단은 반드시 밟아야한다고 한다.  
> 각 칸을 밟을때마다 칸의 점수를 획득한다고 할때, 가장 많이 얻을수있는 점수는 몇점일까~~~요?  

## 코드

```c
#include<stdio.h>
int stair[302]={0,};
int sum[2][202]={0,},n;//sum[0][] - 연속 없이 따로 따로 올라감, sum[1][] - 연속해서 올라감, 다음은 무조건 2칸 가야됨
int main()
{
    scanf("%d",&n);
    for (int i = 0; i < n; i++)
        scanf("%d",&stair[i]);
    sum[0][0]=stair[0];//1칸 올라가며 시작
    sum[0][1]=stair[1];//2칸 올라가며 시작
    sum[1][1]=stair[0]+stair[1];//1,2 올라가며 시작
    for (int i = 2; i < n; i++)
    {
        sum[0][i]=sum[0][i-2]+stair[i];
        sum[1][i]=sum[0][i-1]+stair[i];//이전값에서 바로 1칸 올라옴
        if(sum[0][i-2]<sum[1][i-2])//2칸 올라옴
            sum[0][i]=sum[1][i-2]+stair[i];//연속->2칸 or 연속X->2칸 비교, 더 큰거 선택
    }
    if(sum[0][n-1]<sum[1][n-1])
        printf("%d",sum[1][n-1]);
    else
        printf("%d",sum[0][n-1]);
    return 0;
}
```

## 풀이

DP를 활용해 문제를 해결하였다.

2차원 배열을 활용해, 해당 위치를 올때 연속해서 올라왔는지, 연속하지 않았는지를 저장한다.  
초기값으로, 시작에서 한칸 올라가기, 두칸 올라가기, 한칸씩 두번 올라가기를 넣어준다.  
이후, n까지 반복하며 배열값을 규칙에 맞게 채워준다.  

연속하여 올라오는 경우, 연속하지 않게 올라온 이전값에 현제칸의 값을 저장해 연속하여 올라온 배열에 저장한다.  
연속하지 않게 올라온경우, 2칸 전에서 점프를 뛰어서 올라온 경우인데, 2칸 전의 칸을 연속하게 올라왔는지 아닌지는 중요하지 않다.  
따라서, 2칸 이전의 값중 더 큰값에 현제칸의 값을 더해서 저장한다.  

모든 탐색이 종료되면, 마지막 칸의 두 값중 더 큰걸 출력한다.
