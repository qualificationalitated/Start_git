# 10844

[문제 링크](https://www.acmicpc.net/problem/10844)

> __쉬운 계단 수__
>
> 각 자리의 숫자가 1씩 차이나는 수를 계단수 라고 하자.(45656 -> 계단수)  
> 숫자의 길이 N이 주어질 때, 길이가 N인 계단수가 몇개인지 구해보자  
> 단, 0으로 시작하는 수는 계단수가 아니라고 한다.  

## 코드

```c
#include<stdio.h>
#define MAX 1000000000
int main(){
    int n,i,j,sum=0,dp[101][11]={0,};
    scanf("%d",&n);
    for(i=0;i<=9;i++) 
        dp[1][i] = 1;
    for(i=2;i<=n;i++){
        dp[i][0]=dp[i-1][1];
        dp[i][10]=0;
        for (j=0;j<=9;j++)
            dp[i][j]=(dp[i-1][j-1]+dp[i-1][j+1])%MAX;
    }
    for (i=1;i<=9;i++)
        sum=(sum+dp[n][i])%MAX;
    printf("%d\n",sum);
    return 0;
}
```

## 풀이

dp를 활용해 문제를 해결하였다.  
dp\[n][m] 배열은 길이가 n이고, 끝자리가 m인 계단수의 갯수를 저장한 배열이다.  
자연수 1~9까지는 길이가 1인 계단수이기에, dp\[1][1~9] 배열을 1로 초기화해준다.  
초기화가 완료되었다면 길이 N 까지 탐색하며 dp\[N][x]에 dp\[N-1][x-1]+dp\[N-1][x+1]을 더해준다.  
모든 탐색이 완료되면 dp\[n][]들의 값을 합하여 출력한다.  
