# 2156
https://www.acmicpc.net/problem/2156
>**포도주 시식**
>
>테이블 위에 일렬로 각기 다른 양의 포도주가 든 잔들이 놓여있다.<br>
>아래 규칙에 따라 포도주를 시식하고자 할 때, 마실수 있는 가장 많은 양의 포도주는 얼마일까
>1. 선택한 포도주는 잔에 들어있는 양을 모두 마셔야 하고, 마신 후에는 잔을 원위치 한다.
>2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
## 코드
```c
#include<stdio.h>
int main()
{
    int n,max;
    scanf("%d",&n);
    int wine[n+1],drink[n+1][2];//drink[][0]-> 새로 마시기 drink[][1]-> 2번 연속 마시기
    scanf("%d",&wine[0]);
    drink[0][0]=wine[0];
    drink[0][1]=wine[0];
    max=wine[0];
    for (int i = 1; i < n; i++)
    {
        scanf("%d",&wine[i]);
        //지금까지 봤을때, 연속으로 마시는 최대값 찾기
        drink[i][1]=drink[i-1][0]+wine[i];
        if(drink[i-1][0]+wine[i]<drink[i-1][1])
            drink[i][1]=drink[i-1][1];
        
        if(i==1)
            drink[1][0]=wine[1];
        else {
            int sum=drink[i-2][0];
            if(drink[i-2][0]<drink[i-2][1])
                sum=drink[i-2][1];
            //지금까지 봤을때, 지금 값을 새로 한타임 마셨을때의 최대값 찾기.
            drink[i][0]=sum+wine[i];
            if(sum+wine[i]<drink[i-1][0])
                drink[i][0]=drink[i-1][0];
        }
        for (int j = 0; j < 2; j++)
            if(max<drink[i][j])
                max=drink[i][j];
    }
    printf("%d",max);
    return 0;
}
```
## 풀이
동적 계획법을 활용해 문제를 풀었다.<br>
`drink`배열에 술을 연속으로 마셨을떄, 연속으로 마시지 않았을때 얻을수 있는 최대한의 포도주 양을 저장한다.<br>
지금 포도주를 마신것이 연속으로 마신 경우라면, `drink[현 위치][1]` 에 지금 와인 + 이전에 독립적으로 마신 와인 양을 넣는다.<br>
만일 지금것을 연속으로 마신것보다, 이전의 와인을 연속으로 마신 경우가 더 큰 양을 가지고 있다면, 이전의 것으로 정보를 갱신하여 저장한다.<br>
또한 이번의 마신 포도주를 독립적으로 마신 경우라면, 2칸 전에 마신 와인의 양을 현 와인의 양과 합해 `drink[현 위치][0]`에 저장한다.<br>
2칸 전의 와인은 연속, 독립이 현 와인의 독립에 영향을 미치지 않기에, 둘중 더 큰값을 선택해 값을 더한다.<br>
또한, 이번 와인을 독립적으로 마신것이 한칸 전의 와인을 독립적으로 마신 것보다 양이 작다면, 이전의 값을 현 위치에 기억한다.<br>
마지막까지 가면서 최대값을 찾고, 탐색이 끝난 뒤 값을 출력한다.<br>
