# 11048

[문제 링크](https://www.acmicpc.net/problem/11048)

> __이동하기__
>
> 어느 사람이 N*M크기의 미로의 (1,1)위치에서 (N,M)위치로 이동하고자 한다.  
> 사람은 한번에 미로를 벗어나지 않는 한에서 (x,y+1),(x+1,y),(x+1,y+1)로 이동할 수 있다고 한다.  
> 각 미로의 칸에는 랜덤한갯수의 사탕이 놓여있고, 칸으로 이동하면 사탕을 획득한다.  
> 이 때, 1,1에서 목표지점으로 이동하며 얻을수 있는 최대 사탕의 수를 구하는 문제.

## 코드

```c
#include <stdio.h>
int map[1001][1001],find[1001][1001],mx[3]={1,0,1},my[3]={0,1,1};
int main(void){
    int n, m;
    scanf("%d %d",&n,&m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++){
            scanf("%d", &map[i][j]);
            int ans = 0;
            for (int k = 0; k < 3; k++)
                if(ans<find[i-mx[k]][j-my[k]])
                    ans=find[i-mx[k]][j-my[k]];
            find[i][j] = ans + map[i][j];
        }
    printf("%d",find[n][m]);
}
```

## 풀이

DP를 활용해 문제를 풀이하였다.  

find 배열은 특정 위치까지 도달할 때 얻을수 있는 최대 사탕의 갯수를 저장한 배열이다.  
사람의 이동방향은 [아래,오른쪽,오른쪽아래] - A 로 정해져있기에, 값이 갱신되는쪽은 [왼쪽, 위, 왼쪽위] - B 에서 값이 들어오게 된다.  
자신을 기준으로 B 방향에서의 find값중 최대값을 찾아, 현제위치의 find배열에 새로이 입력받은 값을 추가해 저장한다.  
이로써 find배열의 각 배열값은 최대사탕의 갯수를 저장한다  
입력이 종료되면, find의\[n][m]번쨰 값을 출력한다.  
