# [20310](https://www.acmicpc.net/problem/20310)

## 타노스

### 문제

---

어느 날, 타노스는 0과 1로 이루어진 문자열 $S$를 보았다. 신기하게도, $S$가 포함하는 0의 개수와 $S$가 포함하는 1의 개수는 모두 짝수라고 한다.

갑자기 심술이 난 타노스는 $S$를 구성하는 문자 중 절반의 0과 절반의 1을 제거하여 새로운 문자열 $S'$를 만들고자 한다. $S'$로 가능한 문자열 중 사전순으로 가장 빠른 것을 구하시오.

### 입력

---

문자열 $S$가 주어진다.

### 출력

---

$S'$로 가능한 문자열 중 사전순으로 가장 빠른 것을 출력한다.

## 코드

```c++
#include<iostream>
#include<string>
using namespace std;
int main(){
    int cnt[2]={0,};
    string input;
    cin>>input;
    for(int i=0;i<input.length();i++)     cnt[input[i]-'0']++;
    cnt[0]/=2; cnt[1]/=2;
    for(int i=0;i<input.length();i++){
        if(input[i]=='0' && cnt[0])       cout<<"0";
        if(input[i]=='1' && (!cnt[1]))    cout<<"1";
        cnt[input[i]-'0'] = 0 > cnt[input[i]-'0']-1 ? 0 : cnt[input[i]-'0']-1;
    }
    return 0;
}
```

## 풀이

그리디 문제

처음에는 모든 0과 1의 순서를 바꿀수 있는 것으로 판단해, 각각의 갯수를 체크한 후 사전상 가장 빠른, 0 우선 출력 후 나머지 1 출력을 진행했다.  
그러나 본 문제는 입력의 순서를 뒤바꿀수 없기에(주어진 문자열에서 특정 문자를 지워야만 한다.), 문자열을 출력하며 앞부분에 최대한 많은 0을 놔두는식으로 풀이했다.  
문자열 입력과 동시에 0과 1의 갯수를 배열에 저장한 후, 다시 문자열을 순회하며 규칙에 맞게 숫자를 출력한다.  
가장 작은 수를 출력하기 위해선 높은 자릿수에 위치한 1을 줄이고, 낮은 자릿수에 위치한 0을 줄이면 되기에, 0 갯수가 남아있다면 출력 후 갯수 감소, 1 갯수가 남아있다면 무시 후 갯수 감소를 진행한다.  
